"use strict";var __importDefault=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{default:mod}};Object.defineProperty(exports,"__esModule",{value:true});const VarintTranslator_1=__importDefault(require("./VarintTranslator"));const helpers_1=require("./helpers");const base32_1=require("./base32");class LorDeckCode{static getDeckFromCode(code){const result=[];const bytes=base32_1.base32Decode(code);if(!bytes)throw"Invalid deck code";const byteList=new VarintTranslator_1.default(bytes);const format=byteList.get(0)>>4;const version=byteList.get(0)&15;byteList.sliceAndSet(1);if(version>LorDeckCode.MAX_KNOWN_VERSION){throw"The provided code requires a higher version of this library; please update."}for(let i=3;i>0;i--){const numGroupOfs=byteList.PopVarint();for(let j=0;j<numGroupOfs;j++){const numOfsInThisGroup=byteList.PopVarint();const set=byteList.PopVarint();const faction=byteList.PopVarint();for(let k=0;k<numOfsInThisGroup;k++){const card=byteList.PopVarint();const setString=set.toString().padStart(2,"0");const factionString=this.INT_TO_FACTION_CODE[faction];const cardString=card.toString().padStart(3,"0");const newEntry={cardCode:setString+factionString+cardString,count:i};result.push(newEntry)}}}while(byteList.length>0){const fourPlusCount=byteList.PopVarint();const fourPlusSet=byteList.PopVarint();const fourPlusFaction=byteList.PopVarint();const fourPlusNumber=byteList.PopVarint();const fourPlusSetString=fourPlusSet.toString().padStart(2,"0");const fourPlusFactionString=this.INT_TO_FACTION_CODE[fourPlusFaction];const fourPlusNumberString=fourPlusNumber.toString().padStart(3,"0");const newEntry={cardCode:fourPlusSetString+fourPlusFactionString+fourPlusNumberString,count:fourPlusCount};result.push(newEntry)}return result}static getCodeFromDeck(deck){const bytes=this.GetDeckCodeBytes(deck);const result=base32_1.base32Encode(bytes);return result}static GetDeckCodeBytes(deck){if(!LorDeckCode.ValidCardCodesAndCounts(deck))throw"The provided deck contains invalid card codes.";const formatAndVersion=19;let result=new Uint8Array([formatAndVersion]);const of3=[];const of2=[];const of1=[];let ofN=[];for(const ccc of deck){if(ccc.count==3)of3.push(ccc);else if(ccc.count==2)of2.push(ccc);else if(ccc.count==1)of1.push(ccc);else if(ccc.count<1)throw"Invalid count of "+ccc.count+" for card "+ccc.cardCode;else ofN.push(ccc)}let groupedOf3s=LorDeckCode.GetGroupedOfs(of3);let groupedOf2s=LorDeckCode.GetGroupedOfs(of2);let groupedOf1s=LorDeckCode.GetGroupedOfs(of1);groupedOf3s=LorDeckCode.SortGroupOf(groupedOf3s);groupedOf2s=LorDeckCode.SortGroupOf(groupedOf2s);groupedOf1s=LorDeckCode.SortGroupOf(groupedOf1s);helpers_1.sortDeck(ofN);const encodedGroupedOf3s=LorDeckCode.EncodeGroupOf(groupedOf3s);const encodedGroupedOf2s=LorDeckCode.EncodeGroupOf(groupedOf2s);const encodedGroupedOf1s=LorDeckCode.EncodeGroupOf(groupedOf1s);const encodedOfN=LorDeckCode.EncodeNOfs(ofN);result=helpers_1.mergeUint8Arrays(result,encodedGroupedOf3s);result=helpers_1.mergeUint8Arrays(result,encodedGroupedOf2s);result=helpers_1.mergeUint8Arrays(result,encodedGroupedOf1s);result=helpers_1.mergeUint8Arrays(result,encodedOfN);return result}static GetGroupedOfs(list){const result=[];while(list.length>0){const currentSet=[];const firstCardCode=list[0].cardCode;const{set,faction,number}=LorDeckCode.ParseCardCode(firstCardCode);currentSet.push(list[0]);list.shift();for(let i=list.length-1;i>=0;i--){const currentCardCode=list[i].cardCode;const currentSetNumber=Number(currentCardCode.substring(0,2));const currentFactionCode=currentCardCode.substring(2,4);if(currentSetNumber===set&&currentFactionCode===faction){currentSet.push(list[i]);list.splice(i,1)}}result.push(currentSet)}return result}static EncodeNOfs(nOfs){let bytes=new Uint8Array;for(const ccc of nOfs){bytes=helpers_1.mergeUint8Arrays(bytes,VarintTranslator_1.default.GetVarint(ccc.count));const{set,faction,number}=LorDeckCode.ParseCardCode(ccc.cardCode);const factionNumber=this.FACTION_CODE_TO_INT[faction];bytes=helpers_1.mergeUint8Arrays(bytes,VarintTranslator_1.default.GetVarint(set));bytes=helpers_1.mergeUint8Arrays(bytes,VarintTranslator_1.default.GetVarint(factionNumber));bytes=helpers_1.mergeUint8Arrays(bytes,VarintTranslator_1.default.GetVarint(number))}return bytes}static SortGroupOf(groupOf){const sorted=groupOf.sort((a,b)=>a.length<b.length?-1:1);sorted.forEach(deck=>helpers_1.sortDeck(deck));return sorted}static EncodeGroupOf(groupOf){let bytes=new Uint8Array([]);bytes=helpers_1.mergeUint8Arrays(bytes,VarintTranslator_1.default.GetVarint(groupOf.length));for(const currentList of groupOf){bytes=helpers_1.mergeUint8Arrays(bytes,VarintTranslator_1.default.GetVarint(currentList.length));const currentCardCode=currentList[0].cardCode;const{set,faction}=LorDeckCode.ParseCardCode(currentCardCode);const currentFactionNumber=this.FACTION_CODE_TO_INT[faction];bytes=helpers_1.mergeUint8Arrays(bytes,VarintTranslator_1.default.GetVarint(set));bytes=helpers_1.mergeUint8Arrays(bytes,VarintTranslator_1.default.GetVarint(currentFactionNumber));for(const cd of currentList){const code=cd.cardCode;const sequenceNumber=Number(code.substring(4,7));bytes=helpers_1.mergeUint8Arrays(bytes,VarintTranslator_1.default.GetVarint(sequenceNumber))}}return bytes}static ParseCardCode(code){return{set:Number(code.substring(0,2)),faction:code.substring(2,4),number:Number(code.substring(4,7))}}static ValidCardCodesAndCounts(deck){for(const ccc of deck){if(ccc.cardCode.length!=LorDeckCode.CARD_CODE_LENGTH)return false;if(isNaN(Number(ccc.cardCode.substring(0,2))))return false;const faction=ccc.cardCode.substring(2,4);if(this.FACTION_CODE_TO_INT[faction]===undefined)return false;if(isNaN(Number(ccc.cardCode.substring(4,7))))return false;if(ccc.count<1)return false}return true}}LorDeckCode.CARD_CODE_LENGTH=7;LorDeckCode.MAX_KNOWN_VERSION=3;LorDeckCode.FACTION_CODE_TO_INT={DE:0,FR:1,IO:2,NX:3,PZ:4,SI:5,BW:6,SH:7,MT:9};LorDeckCode.INT_TO_FACTION_CODE={0:"DE",1:"FR",2:"IO",3:"NX",4:"PZ",5:"SI",6:"BW",7:"SH",9:"MT"};exports.default=LorDeckCode;"use strict";Object.defineProperty(exports,"__esModule",{value:true});class VarintTranslator{constructor(_bytes){this.bytes=new Uint8Array(_bytes)}get length(){return this.bytes.length}PopVarint(){let result=0;let currentShift=0;let bytesPopped=0;for(let i=0;i<this.bytes.length;i++){bytesPopped++;const current=this.bytes[i]&VarintTranslator.AllButMSB;result|=current<<currentShift;if((this.bytes[i]&VarintTranslator.JustMSB)!=VarintTranslator.JustMSB){this.bytes=this.bytes.slice(bytesPopped);return result}currentShift+=7}throw"Byte array did not contain valid varints."}sliceAndSet(begin,end){this.bytes=this.bytes.slice(begin,end)}get(index){return this.bytes[index]}static GetVarint(value){const buff=new Uint8Array(10);let currentIndex=0;if(value==0)return new Uint8Array([0]);while(value!==0){let byteVal=value&this.AllButMSB;value>>=7;if(value!=0)byteVal|=this.JustMSB;buff[currentIndex++]=byteVal}return buff.slice(0,currentIndex)}}exports.default=VarintTranslator;VarintTranslator.AllButMSB=127;VarintTranslator.JustMSB=128;"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.base32Decode=exports.base32Encode=void 0;const alphabet="ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";function base32Encode(buffer){const length=buffer.byteLength;const binaryData=new Uint8Array(buffer);let numBitsProcessed=0;let encodedString="";let value=0;for(let idx=0;idx<length;idx++){value=value<<8|binaryData[idx];numBitsProcessed+=8;while(numBitsProcessed>=5){encodedString+=alphabet[value>>>numBitsProcessed-5&31];numBitsProcessed-=5}}if(numBitsProcessed>0){encodedString+=alphabet[value<<5-numBitsProcessed&31]}while(encodedString.length%8!==0){encodedString+="="}return encodedString}exports.base32Encode=base32Encode;function base32Decode(input){function readCharOrThrowError(char){const idx=alphabet.indexOf(char);if(idx===-1){throw new Error("Invalid character found: "+char)}return idx}const cleanedInput=input.toUpperCase().replace(/\=+$/,"");let numBitsProcessed=0;let outputIdx=0;let value=0;const output=new Uint8Array(cleanedInput.length*5/8|0);for(let currCharOfInput=0;currCharOfInput<cleanedInput.length;currCharOfInput++){value=value<<5|readCharOrThrowError(cleanedInput[currCharOfInput]);numBitsProcessed+=5;if(numBitsProcessed>=8){output[outputIdx++]=value>>>numBitsProcessed-8&255;numBitsProcessed-=8}}return output.buffer}exports.base32Decode=base32Decode;"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.mergeUint8Arrays=exports.sortDeck=void 0;function sortDeck(deck){deck.sort((a,b)=>a.cardCode<b.cardCode?-1:1)}exports.sortDeck=sortDeck;function mergeUint8Arrays(a,b){const merged=new Uint8Array(a.length+b.length);merged.set(a);merged.set(b,a.length);return merged}exports.mergeUint8Arrays=mergeUint8Arrays;